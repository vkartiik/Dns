import os
import socket
import whois
import dns.resolver
import csv
import requests
import sys
import time
import subprocess

domains = [
    "nfsu.ac.in",
    "mohfw.gov.in",
    "nic.in",
    "sbi.co.in",
    "nitiayog.gov.in",
    "nixi.in",
    "registry.in",
    "cdac.in",
    "stpi.in",
    "nasscom.in"
]

phishing_keywords = ["login", "secure", "verify", "update", "gov", "account", "service", "portal"]

free_dns_keywords = ["freenom", "000webhost", "infinityfree", "freehosting", "byet.host"]

resolver = dns.resolver.Resolver()
resolver.timeout = 2
resolver.lifetime = 2

def get_ip(domain):
    """Get IPv4 address (legacy function for backward compatibility)"""
    try:
        return socket.gethostbyname(domain)
    except:
        return None

def get_all_ips(domain):
    """Get both IPv4 and IPv6 addresses for a domain"""
    ipv4 = None
    ipv6 = None
    
    try:
        # Get IPv4
        try:
            ipv4 = socket.gethostbyname(domain)
        except:
            pass
        
        # Get IPv6
        try:
            ipv6_list = socket.getaddrinfo(domain, None, socket.AF_INET6)
            if ipv6_list:
                ipv6 = ipv6_list[0][4][0]
        except:
            pass
            
        return ipv4, ipv6
    except:
        return None, None

def get_ttl(domain):
    try:
        answers = resolver.resolve(domain, 'A')
        # Get TTL from the first answer
        if answers and len(answers) > 0:
            return answers.rrset.ttl
        return None
    except Exception as e:
        return None

def get_ns(domain):
    try:
        answers = resolver.resolve(domain, 'NS')
        return [str(rdata).lower() for rdata in answers]
    except Exception as e:
        return []

def get_whois(domain):
    try:
        return whois.whois(domain)
    except:
        return {}

def calculate_risk(domain, ipv4, ipv6, ttl, ns_list, whois_info):
    score = 0
    reasons = []

    # Doesn't resolve to any IP
    if not ipv4 and not ipv6:
        score += 5
        reasons.append("Domain did not resolve to any IP")
        return score, reasons

    # Suspicious keyword in domain
    if any(k in domain.lower() for k in phishing_keywords):
        score += 5
        reasons.append("Phishing keyword in domain")

    # Free DNS providers
    if any(free_dns in str(ns).lower() for ns in ns_list for free_dns in free_dns_keywords):
        score += 4
        reasons.append("Uses free DNS provider")

    # TTL too low
    if ttl is not None and ttl < 300:
        score += 2
        reasons.append("Very low TTL (evasion)")

    # NS mismatch with WHOIS (if WHOIS gives data)
    if whois_info and hasattr(whois_info, 'name_servers') and whois_info.name_servers:
        ns_mismatch = all(ns.lower() not in str(whois_info.name_servers).lower() for ns in ns_list)
        if ns_mismatch:
            score += 3
            reasons.append("NS mismatch with WHOIS")

    # .gov.in or .nic.in domain hosted outside India (non-103.x or 117.x IP)
    # Check both IPv4 and IPv6
    gov_domain = ".gov.in" in domain or "nic.in" in domain
    if gov_domain:
        ipv4_outside = ipv4 and not (ipv4.startswith("103.") or ipv4.startswith("117."))
        ipv6_outside = ipv6 and not (ipv6.startswith("2405:") or ipv6.startswith("2401:") or ipv6.startswith("2001:"))
        
        if ipv4_outside or ipv6_outside:
            score += 5
            reasons.append("Govt-like domain hosted outside India")

    return score, reasons

# --- VirusTotal Integration ---
VT_API_KEY = "ab2aa4e27e18ad22ee31e8b51dacd87607cf08bb2fea89ed14911a9d965efc1a"

def check_virustotal(domain):
    if VT_API_KEY == "YOUR_VIRUSTOTAL_API_KEY":
        return "No API Key"
    url = f"https://www.virustotal.com/api/v3/domains/{domain}"
    headers = {"x-apikey": VT_API_KEY}
    try:
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            data = response.json()
            stats = data['data']['attributes']['last_analysis_stats']
            malicious = stats.get('malicious', 0)
            suspicious = stats.get('suspicious', 0)
            if malicious > 0 or suspicious > 0:
                return f"Malicious ({malicious}), Suspicious ({suspicious})"
            else:
                return "Clean"
        else:
            return f"Error {response.status_code}"
    except Exception as e:
        return f"Error: {e}"

# --- AbuseIPDB Integration ---
ABUSEIPDB_API_KEY = "f38ce2070ce22fbebeebaff1feefc71b35a686b42a4c7a4822d8f8a27fb46b2eb87ff56261ab4e20"

def check_abuseipdb(ip):
    if not ip or ip == "N/A":
        return "No IP"
    url = f"https://api.abuseipdb.com/api/v2/check?ipAddress={ip}&maxAgeInDays=90"
    headers = {"Key": ABUSEIPDB_API_KEY, "Accept": "application/json"}
    try:
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            data = response.json()
            score = data['data']['abuseConfidenceScore']
            if score > 0:
                return f"Abuse Score: {score}"
            else:
                return "Clean"
        else:
            return f"Error {response.status_code}"
    except Exception as e:
        return f"Error: {e}"

def check_abuseipdb_both(ipv4, ipv6):
    """Check both IPv4 and IPv6 addresses with AbuseIPDB"""
    results = []
    
    if ipv4 and ipv4 != "N/A":
        results.append(f"IPv4: {check_abuseipdb(ipv4)}")
    
    if ipv6 and ipv6 != "N/A":
        results.append(f"IPv6: {check_abuseipdb(ipv6)}")
    
    if not results:
        return "No IPs to check"
    
    return " | ".join(results)

# --- NIXI DNS Compliance Check ---
INDIAN_IP_PREFIXES = ["103.", "117."]
INDIAN_IPV6_PREFIXES = ["2405:", "2401:", "2001:"]

def is_nixi_compliant(ipv4, ipv6, ns_list):
    # Check if IPv4 is Indian
    if ipv4 and any(ipv4.startswith(prefix) for prefix in INDIAN_IP_PREFIXES):
        return "Yes"
    
    # Check if IPv6 is Indian
    if ipv6 and any(ipv6.startswith(prefix) for prefix in INDIAN_IPV6_PREFIXES):
        return "Yes"
    
    # Check if any NS is Indian (by name or IP, can be expanded)
    for ns in ns_list:
        if any(prefix in ns for prefix in INDIAN_IP_PREFIXES + INDIAN_IPV6_PREFIXES):
            return "Yes"
    
    return "No"

def analyze_domain(domain):
    """Streamlined domain analysis function with IPv4 and IPv6 support"""
    try:
        print(f"\nüåê Checking: {domain}", flush=True)

        # Get all domain information
        ipv4, ipv6 = get_all_ips(domain)
        ttl = get_ttl(domain)
        ns_list = get_ns(domain)
        whois_info = get_whois(domain)

        # Calculate risk
        score, reasons = calculate_risk(domain, ipv4, ipv6, ttl, ns_list, whois_info)
        normalized_score = min(round((score / 24) * 5, 2), 5)
        status = "üö® HIGH RISK" if normalized_score >= 4 else "‚ö†Ô∏è Medium" if normalized_score >= 2 else "‚úÖ Safe"

        # Get external reputation data
        vt_status = check_virustotal(domain)
        abuseipdb_status = check_abuseipdb_both(ipv4, ipv6)
        nixi_status = is_nixi_compliant(ipv4, ipv6, ns_list) if any(s in domain for s in [".in", ".gov.in", ".nic.in"]) else "N/A"

        # Print results
        print(f"  IPv4: {ipv4 or 'N/A'}", flush=True)
        print(f"  IPv6: {ipv6 or 'N/A'}", flush=True)
        print(f"  TTL: {ttl or 'N/A'}", flush=True)
        print(f"  NS: {', '.join(ns_list) if ns_list else 'N/A'}", flush=True)
        print(f"  üß† Risk Score (out of 5): {normalized_score}", flush=True)
        print(f"  ‚ö†Ô∏è Reasons: {', '.join(reasons)}", flush=True)
        print(f"  üõ°Ô∏è Status: {status}", flush=True)
        print(f"  ü¶† VirusTotal: {vt_status}", flush=True)
        print(f"  üö® AbuseIPDB: {abuseipdb_status}", flush=True)
        print(f"  üáÆüá≥ NIXI Compliant: {nixi_status}", flush=True)

        return [
            domain,
            ipv4 or "N/A",
            ipv6 or "N/A",
            ttl or "N/A",
            ", ".join(ns_list) if ns_list else "N/A",
            normalized_score,
            ", ".join(reasons),
            status,
            vt_status,
            abuseipdb_status,
            nixi_status
        ]
    except Exception as e:
        print(f"[ERROR] Failed to process {domain}: {e}", flush=True)
        return [domain, "N/A", "N/A", "N/A", "N/A", "N/A", f"Error: {e}", "‚ùå Error", "Error", "Error"]

if __name__ == "__main__":
    # Main DNS Abuse and Reputation Analysis
    output_csv = os.path.join(os.path.dirname(os.path.abspath(__file__)), "high_risk_dns_report.csv")
    all_results = []
    
    try:
        with open(output_csv, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["Domain", "IPv4", "IPv6", "TTL", "Name Servers", "Risk Score", "Reasons", "Status", "VirusTotal", "AbuseIPDB", "NIXI Compliant"])

            # Process each domain
            for domain in domains:
                result = analyze_domain(domain)
                writer.writerow(result)
                all_results.append(result)
                
    except Exception as e:
        print(f"[FATAL ERROR] Could not write to CSV: {e}", flush=True)
        exit(1)

    print(f"\n‚úÖ Report saved to: {output_csv}", flush=True)
    print(f"\nSummary:", flush=True)
    for row in all_results:
        print(f"{row[0]}: {row[-4]} | VT: {row[-3]} | AbuseIPDB: {row[-2]} | NIXI: {row[-1]}", flush=True)
